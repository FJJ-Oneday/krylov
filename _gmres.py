import numpy as np
from typing import Callable
from scipy import linalg

from . import givens
from ._check import check_parameters



def gmres(A, b, maxiter: int=None, tol=1e-6, *, x0=None, dtype=None, 
          pre: Callable[[np.ndarray], np.ndarray]=None, **kwargs) -> tuple[np.ndarray, dict]:
    """
    Using GMRES solve linear equation:
        A * x = b,
    Which x belong to Krylov space K(A, b).

    Parameters
    ----------
    a: (M, M) array like
        Input arrary.
    b: (M, 1) or (M, ) array like
        Right side vector.
    x0: (M, 1) or (M, ) array like
        Inital start vector.
    maxiter: int, optional
        Maximun iteration. Default is `a.shape[0]`.
    tol: float, optional
        Stop criterion.
    dtype: np.dtype
        data type, `int`, `complex`, .... .
    pre: `Callable`
        preconditioner, which is a map from C^n into C^n.

    Returns
    -------
    x: (M, 1) or (M, ) array like
        Solution of the equation.
    info: Dict
        Which following keys:
            `info['exitflag']`: {0, 1}. 0 is succeed, 1 is failed.
            `info['iter']`: total iterations.
            `info['resvec']`: a vector of residual.
            `info['relres']`: relative error.
    """
    check_parameters(pre)

    n = b.size

    if not callable(A):
        A_Mult = lambda x: A.dot(x)
    else:
        A_Mult = A

    if x0 is None:
        r = b
    else:
        r = b - A_Mult(x0)
    
    if maxiter is None:
        maxiter = n

    if not pre:
        pre = lambda x: x

    eta = linalg.norm(r)
    v = r / eta

    Q, H = np.zeros((n, maxiter + 1), dtype=dtype), \
        np.zeros((maxiter + 1, maxiter), dtype=dtype)
    cs = np.zeros((maxiter, 2), dtype=dtype)
    p = np.zeros(maxiter+1, dtype=dtype)
    p[0] = eta
    
    iscomplex = (dtype == complex)

    Q[:, 0] = v
    flag, resvec, relres = 1, np.array([eta]), 1
    for j in range(maxiter):

        if kwargs.get('show_details'):
            if (j % kwargs['show_details']) == 0 or (resvec[-1] < tol):
                print('COCG-iters: ', j, ', res: ', resvec[-1])

        v = A_Mult(pre(Q[:, j]))
        for i in range(j+1):
            qi = Q[:, i]
            H[i, j] = np.vdot(qi, v)
            v = v - H[i, j] * qi

        beta = linalg.norm(v)
        H[j+1, j] = beta

        # givens rotation
        for k in range(j):
            c, s = cs[k]
            g = np.array([[c.conjugate(), -s],
                          [s.conjugate(), c]])
            H[k:k+2, j] = g.dot(H[k:k+2, j])
        
        c, s, r = givens(*H[j:j+2, j], iscomplex=iscomplex)

        # update cs matrix which stores c, s generated by givens rotation
        cs[j, :] = [c, s]

        # update Hessenberg matrix and p vector
        H[j:j+2, j] = [r, 0]
        
        p[j:j+2] = p[j] * np.array([c.conjugate(), s.conjugate()])

        # stop criterion
        rho = abs(p[j+1])
        resvec = np.append(resvec, rho)
        if rho < tol:
            flag = 0
            break
        Q[:, j+1] = v / beta
    
    x = linalg.solve_triangular(H[:j+1, :j+1], p[:j+1])

    x = pre(Q[:, :j+1].dot(x))

    if x0 is not None:
        x = x0 + x

    info = {'exitflag': flag, 'iters': j+1, 'resvec': resvec}

    return x, info